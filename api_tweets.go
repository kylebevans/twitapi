/*
 * Early Access
 *
 * API Reference â€” v2
 *
 * API version: 2.2
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package twitapi

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
	"reflect"
)

// Linger please
var (
	_ _context.Context
)

// TweetsApiService TweetsApi service
type TweetsApiService service

// AddOrDeleteRulesOpts Optional parameters for the method 'AddOrDeleteRules'
//type AddOrDeleteRulesOpts struct {
//    DryRun optional.Bool
//}

/*
AddOrDeleteRules Add or delete rules from a user's active rule set.
Add or delete rules from a user&#39;s active rule set. Users can provide unique, optionally tagged rules to add. Users can delete their entire rule set or a subset specified by rule ids or values.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param addOrDeleteRulesRequest
 * @param optional nil or *AddOrDeleteRulesOpts - Optional Parameters:
 * @param "DryRun" (optional.Bool) -  Dry Run can be used with both the add and delete action, with the expected result given, but without actually taking any action in the system (meaning the end state will always be as it was when the request was submitted). This is particularly useful to validate rule changes.
@return AddOrDeleteRulesResponse
*/
func (a *TweetsApiService) AddOrDeleteRules(ctx _context.Context, addOrDeleteRulesRequest AddOrDeleteRulesRequest, localVarOptionals *AddOrDeleteRulesOpts) (AddOrDeleteRulesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AddOrDeleteRulesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/2/tweets/search/stream/rules"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.DryRun.IsSet() {
		localVarQueryParams.Add("dry_run", parameterToString(localVarOptionals.DryRun.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = &addOrDeleteRulesRequest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// FindTweetByIdOpts Optional parameters for the method 'FindTweetById'
type FindTweetByIdOpts struct {
    Expansions optional.Interface
    TweetFields optional.Interface
    UserFields optional.Interface
    MediaFields optional.Interface
    PlaceFields optional.Interface
    PollFields optional.Interface
}

/*
FindTweetById Returns hydrated Tweet objects
Returns a variety of information about the Tweet specified by the requested ID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id A single Tweet ID.
 * @param optional nil or *FindTweetByIdOpts - Optional Parameters:
 * @param "Expansions" (optional.Interface of []string) -  A comma separated list of fields to expand.
 * @param "TweetFields" (optional.Interface of []string) -  A comma separated list of Tweet fields to display.
 * @param "UserFields" (optional.Interface of []string) -  A comma separated list of User fields to display.
 * @param "MediaFields" (optional.Interface of []string) -  A comma separated list of Media fields to display.
 * @param "PlaceFields" (optional.Interface of []string) -  A comma separated list of Place fields to display.
 * @param "PollFields" (optional.Interface of []string) -  A comma separated list of Poll fields to display.
@return SingleTweetLookupResponse
*/
func (a *TweetsApiService) FindTweetById(ctx _context.Context, id string, localVarOptionals *FindTweetByIdOpts) (SingleTweetLookupResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SingleTweetLookupResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/2/tweets/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Expansions.IsSet() {
		localVarQueryParams.Add("expansions", parameterToString(localVarOptionals.Expansions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.TweetFields.IsSet() {
		localVarQueryParams.Add("tweet.fields", parameterToString(localVarOptionals.TweetFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.UserFields.IsSet() {
		localVarQueryParams.Add("user.fields", parameterToString(localVarOptionals.UserFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MediaFields.IsSet() {
		localVarQueryParams.Add("media.fields", parameterToString(localVarOptionals.MediaFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.PlaceFields.IsSet() {
		localVarQueryParams.Add("place.fields", parameterToString(localVarOptionals.PlaceFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.PollFields.IsSet() {
		localVarQueryParams.Add("poll.fields", parameterToString(localVarOptionals.PollFields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// FindTweetsByIdOpts Optional parameters for the method 'FindTweetsById'
type FindTweetsByIdOpts struct {
    Expansions optional.Interface
    TweetFields optional.Interface
    UserFields optional.Interface
    MediaFields optional.Interface
    PlaceFields optional.Interface
    PollFields optional.Interface
}

/*
FindTweetsById Returns hydrated Tweet objects
Returns a variety of information about the Tweet specified by the requested ID
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param ids A comma separated list of Tweet IDs. Up to 100 are allowed in a single request.
 * @param optional nil or *FindTweetsByIdOpts - Optional Parameters:
 * @param "Expansions" (optional.Interface of []string) -  A comma separated list of fields to expand.
 * @param "TweetFields" (optional.Interface of []string) -  A comma separated list of Tweet fields to display.
 * @param "UserFields" (optional.Interface of []string) -  A comma separated list of User fields to display.
 * @param "MediaFields" (optional.Interface of []string) -  A comma separated list of Media fields to display.
 * @param "PlaceFields" (optional.Interface of []string) -  A comma separated list of Place fields to display.
 * @param "PollFields" (optional.Interface of []string) -  A comma separated list of Poll fields to display.
@return TweetLookupResponse
*/
func (a *TweetsApiService) FindTweetsById(ctx _context.Context, ids []string, localVarOptionals *FindTweetsByIdOpts) (TweetLookupResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TweetLookupResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/2/tweets"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if len(ids) < 1 {
		return localVarReturnValue, nil, reportError("ids must have at least 1 elements")
	}
	if len(ids) > 100 {
		return localVarReturnValue, nil, reportError("ids must have less than 100 elements")
	}

	localVarQueryParams.Add("ids", parameterToString(ids, "csv"))
	if localVarOptionals != nil && localVarOptionals.Expansions.IsSet() {
		localVarQueryParams.Add("expansions", parameterToString(localVarOptionals.Expansions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.TweetFields.IsSet() {
		localVarQueryParams.Add("tweet.fields", parameterToString(localVarOptionals.TweetFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.UserFields.IsSet() {
		localVarQueryParams.Add("user.fields", parameterToString(localVarOptionals.UserFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MediaFields.IsSet() {
		localVarQueryParams.Add("media.fields", parameterToString(localVarOptionals.MediaFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.PlaceFields.IsSet() {
		localVarQueryParams.Add("place.fields", parameterToString(localVarOptionals.PlaceFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.PollFields.IsSet() {
		localVarQueryParams.Add("poll.fields", parameterToString(localVarOptionals.PollFields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetRulesOpts Optional parameters for the method 'GetRules'
//type GetRulesOpts struct {
//    Ids optional.Interface
//}

/*
GetRules Returns rules from a user's active rule set.
Returns rules from a user&#39;s active rule set. Users can fetch all of their rules or a subset, specified by the provided rule ids.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GetRulesOpts - Optional Parameters:
 * @param "Ids" (optional.Interface of []string) -  A comma-separated list of Rule IDs.
@return InlineResponse2002
*/
func (a *TweetsApiService) GetRules(ctx _context.Context, localVarOptionals *GetRulesOpts) (InlineResponse2002, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2002
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/2/tweets/search/stream/rules"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Ids.IsSet() {
		t:=localVarOptionals.Ids.Value()
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				localVarQueryParams.Add("ids", parameterToString(s.Index(i), "multi"))
			}
		} else {
			localVarQueryParams.Add("ids", parameterToString(t, "multi"))
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// HideReplyByIdOpts Optional parameters for the method 'HideReplyById'
type HideReplyByIdOpts struct {
    InlineObject optional.Interface
}

/*
HideReplyById Hides or unhides a reply to an owned conversation.
Tweet ID in the path is that of the reply to hide or unhide.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id The ID of the reply that you want to hide or unhide.
 * @param optional nil or *HideReplyByIdOpts - Optional Parameters:
 * @param "InlineObject" (optional.Interface of InlineObject) - 
@return InlineResponse200
*/
func (a *TweetsApiService) HideReplyById(ctx _context.Context, id string, localVarOptionals *HideReplyByIdOpts) (InlineResponse200, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/2/tweets/{id}/hidden"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", _neturl.QueryEscape(parameterToString(id, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.InlineObject.IsSet() {
		localVarOptionalInlineObject, localVarOptionalInlineObjectok := localVarOptionals.InlineObject.Value().(InlineObject)
		if !localVarOptionalInlineObjectok {
			return localVarReturnValue, nil, reportError("inlineObject should be InlineObject")
		}
		localVarPostBody = &localVarOptionalInlineObject
	}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SampleStreamOpts Optional parameters for the method 'SampleStream'
type SampleStreamOpts struct {
    Expansions optional.Interface
    TweetFields optional.Interface
    UserFields optional.Interface
    MediaFields optional.Interface
    PlaceFields optional.Interface
    PollFields optional.Interface
}

/*
SampleStream Streams a deterministic 1% of public tweets.
Streams a deterministic 1% of public tweets.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SampleStreamOpts - Optional Parameters:
 * @param "Expansions" (optional.Interface of []string) -  A comma separated list of fields to expand.
 * @param "TweetFields" (optional.Interface of []string) -  A comma separated list of Tweet fields to display.
 * @param "UserFields" (optional.Interface of []string) -  A comma separated list of User fields to display.
 * @param "MediaFields" (optional.Interface of []string) -  A comma separated list of Media fields to display.
 * @param "PlaceFields" (optional.Interface of []string) -  A comma separated list of Place fields to display.
 * @param "PollFields" (optional.Interface of []string) -  A comma separated list of Poll fields to display.
@return StreamingTweet
*/
func (a *TweetsApiService) SampleStream(ctx _context.Context, localVarOptionals *SampleStreamOpts) (StreamingTweet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  StreamingTweet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/2/tweets/sample/stream"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Expansions.IsSet() {
		localVarQueryParams.Add("expansions", parameterToString(localVarOptionals.Expansions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.TweetFields.IsSet() {
		localVarQueryParams.Add("tweet.fields", parameterToString(localVarOptionals.TweetFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.UserFields.IsSet() {
		localVarQueryParams.Add("user.fields", parameterToString(localVarOptionals.UserFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MediaFields.IsSet() {
		localVarQueryParams.Add("media.fields", parameterToString(localVarOptionals.MediaFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.PlaceFields.IsSet() {
		localVarQueryParams.Add("place.fields", parameterToString(localVarOptionals.PlaceFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.PollFields.IsSet() {
		localVarQueryParams.Add("poll.fields", parameterToString(localVarOptionals.PollFields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// SearchStreamOpts Optional parameters for the method 'SearchStream'
type SearchStreamOpts struct {
    Expansions optional.Interface
    TweetFields optional.Interface
    UserFields optional.Interface
    MediaFields optional.Interface
    PlaceFields optional.Interface
    PollFields optional.Interface
}

/*
SearchStream Streams tweets matching a user's active rule set.
Streams tweets matching a user&#39;s active rule set.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *SearchStreamOpts - Optional Parameters:
 * @param "Expansions" (optional.Interface of []string) -  A comma separated list of fields to expand.
 * @param "TweetFields" (optional.Interface of []string) -  A comma separated list of Tweet fields to display.
 * @param "UserFields" (optional.Interface of []string) -  A comma separated list of User fields to display.
 * @param "MediaFields" (optional.Interface of []string) -  A comma separated list of Media fields to display.
 * @param "PlaceFields" (optional.Interface of []string) -  A comma separated list of Place fields to display.
 * @param "PollFields" (optional.Interface of []string) -  A comma separated list of Poll fields to display.
@return FilteredStreamingTweet
*/
func (a *TweetsApiService) SearchStream(ctx _context.Context, localVarOptionals *SearchStreamOpts) (FilteredStreamingTweet, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FilteredStreamingTweet
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/2/tweets/search/stream"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Expansions.IsSet() {
		localVarQueryParams.Add("expansions", parameterToString(localVarOptionals.Expansions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.TweetFields.IsSet() {
		localVarQueryParams.Add("tweet.fields", parameterToString(localVarOptionals.TweetFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.UserFields.IsSet() {
		localVarQueryParams.Add("user.fields", parameterToString(localVarOptionals.UserFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MediaFields.IsSet() {
		localVarQueryParams.Add("media.fields", parameterToString(localVarOptionals.MediaFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.PlaceFields.IsSet() {
		localVarQueryParams.Add("place.fields", parameterToString(localVarOptionals.PlaceFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.PollFields.IsSet() {
		localVarQueryParams.Add("poll.fields", parameterToString(localVarOptionals.PollFields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TweetsFullarchiveSearchOpts Optional parameters for the method 'TweetsFullarchiveSearch'
//type TweetsFullarchiveSearchOpts struct {
//    StartTime optional.Time
//    EndTime optional.Time
//    SinceId optional.String
//    UntilId optional.String
//    MaxResults optional.Int32
//    NextToken optional.String
//    Expansions optional.Interface
//    TweetFields optional.Interface
//    UserFields optional.Interface
//    MediaFields optional.Interface
//    PlaceFields optional.Interface
//    PollFields optional.Interface
//}

/*
TweetsFullarchiveSearch Returns Tweets that match a search query.
Returns Tweets that match a search query.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param query One query/rule/filter for matching Tweets. Up to 1024 characters.
 * @param optional nil or *TweetsFullarchiveSearchOpts - Optional Parameters:
 * @param "StartTime" (optional.Time) -  YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
 * @param "EndTime" (optional.Time) -  YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
 * @param "SinceId" (optional.String) -  Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
 * @param "UntilId" (optional.String) -  Returns results with a Tweet ID less than (that is, older than) the specified ID.
 * @param "MaxResults" (optional.Int32) -  The maximum number of search results to be returned by a request.
 * @param "NextToken" (optional.String) -  This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
 * @param "Expansions" (optional.Interface of []string) -  A comma separated list of fields to expand.
 * @param "TweetFields" (optional.Interface of []string) -  A comma separated list of Tweet fields to display.
 * @param "UserFields" (optional.Interface of []string) -  A comma separated list of User fields to display.
 * @param "MediaFields" (optional.Interface of []string) -  A comma separated list of Media fields to display.
 * @param "PlaceFields" (optional.Interface of []string) -  A comma separated list of Place fields to display.
 * @param "PollFields" (optional.Interface of []string) -  A comma separated list of Poll fields to display.
@return InlineResponse2001
*/
func (a *TweetsApiService) TweetsFullarchiveSearch(ctx _context.Context, query string, localVarOptionals *TweetsFullarchiveSearchOpts) (InlineResponse2001, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2001
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/2/tweets/search/all"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(query) < 1 {
		return localVarReturnValue, nil, reportError("query must have at least 1 elements")
	}
	if strlen(query) > 1024 {
		return localVarReturnValue, nil, reportError("query must have less than 1024 elements")
	}

	localVarQueryParams.Add("query", parameterToString(query, ""))
	if localVarOptionals != nil && localVarOptionals.StartTime.IsSet() {
		localVarQueryParams.Add("start_time", parameterToString(localVarOptionals.StartTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndTime.IsSet() {
		localVarQueryParams.Add("end_time", parameterToString(localVarOptionals.EndTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SinceId.IsSet() {
		localVarQueryParams.Add("since_id", parameterToString(localVarOptionals.SinceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UntilId.IsSet() {
		localVarQueryParams.Add("until_id", parameterToString(localVarOptionals.UntilId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxResults.IsSet() {
		localVarQueryParams.Add("max_results", parameterToString(localVarOptionals.MaxResults.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NextToken.IsSet() {
		localVarQueryParams.Add("next_token", parameterToString(localVarOptionals.NextToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Expansions.IsSet() {
		localVarQueryParams.Add("expansions", parameterToString(localVarOptionals.Expansions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.TweetFields.IsSet() {
		localVarQueryParams.Add("tweet.fields", parameterToString(localVarOptionals.TweetFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.UserFields.IsSet() {
		localVarQueryParams.Add("user.fields", parameterToString(localVarOptionals.UserFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MediaFields.IsSet() {
		localVarQueryParams.Add("media.fields", parameterToString(localVarOptionals.MediaFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.PlaceFields.IsSet() {
		localVarQueryParams.Add("place.fields", parameterToString(localVarOptionals.PlaceFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.PollFields.IsSet() {
		localVarQueryParams.Add("poll.fields", parameterToString(localVarOptionals.PollFields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// TweetsRecentSearchOpts Optional parameters for the method 'TweetsRecentSearch'
//type TweetsRecentSearchOpts struct {
//    StartTime optional.Time
//    EndTime optional.Time
//    SinceId optional.String
//    UntilId optional.String
//    MaxResults optional.Int32
//    NextToken optional.String
//    Expansions optional.Interface
//    TweetFields optional.Interface
//    UserFields optional.Interface
//    MediaFields optional.Interface
//    PlaceFields optional.Interface
//    PollFields optional.Interface
//}

/*
TweetsRecentSearch Returns Tweets from the last 7 days that match a search query.
Returns Tweets from the last 7 days that match a search query.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param query One query/rule/filter for matching Tweets. Up to 512 characters.
 * @param optional nil or *TweetsRecentSearchOpts - Optional Parameters:
 * @param "StartTime" (optional.Time) -  YYYY-MM-DDTHH:mm:ssZ. The oldest UTC timestamp (from most recent 7 days) from which the Tweets will be provided. Timestamp is in second granularity and is inclusive (i.e. 12:00:01 includes the first second of the minute).
 * @param "EndTime" (optional.Time) -  YYYY-MM-DDTHH:mm:ssZ. The newest, most recent UTC timestamp to which the Tweets will be provided. Timestamp is in second granularity and is exclusive (i.e. 12:00:01 excludes the first second of the minute).
 * @param "SinceId" (optional.String) -  Returns results with a Tweet ID greater than (that is, more recent than) the specified ID.
 * @param "UntilId" (optional.String) -  Returns results with a Tweet ID less than (that is, older than) the specified ID.
 * @param "MaxResults" (optional.Int32) -  The maximum number of search results to be returned by a request.
 * @param "NextToken" (optional.String) -  This parameter is used to get the next 'page' of results. The value used with the parameter is pulled directly from the response provided by the API, and should not be modified.
 * @param "Expansions" (optional.Interface of []string) -  A comma separated list of fields to expand.
 * @param "TweetFields" (optional.Interface of []string) -  A comma separated list of Tweet fields to display.
 * @param "UserFields" (optional.Interface of []string) -  A comma separated list of User fields to display.
 * @param "MediaFields" (optional.Interface of []string) -  A comma separated list of Media fields to display.
 * @param "PlaceFields" (optional.Interface of []string) -  A comma separated list of Place fields to display.
 * @param "PollFields" (optional.Interface of []string) -  A comma separated list of Poll fields to display.
@return TweetSearchResponse
*/
func (a *TweetsApiService) TweetsRecentSearch(ctx _context.Context, query string, localVarOptionals *TweetsRecentSearchOpts) (TweetSearchResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TweetSearchResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/2/tweets/search/recent"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if strlen(query) < 1 {
		return localVarReturnValue, nil, reportError("query must have at least 1 elements")
	}
	if strlen(query) > 512 {
		return localVarReturnValue, nil, reportError("query must have less than 512 elements")
	}

	localVarQueryParams.Add("query", parameterToString(query, ""))
	if localVarOptionals != nil && localVarOptionals.StartTime.IsSet() {
		localVarQueryParams.Add("start_time", parameterToString(localVarOptionals.StartTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EndTime.IsSet() {
		localVarQueryParams.Add("end_time", parameterToString(localVarOptionals.EndTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SinceId.IsSet() {
		localVarQueryParams.Add("since_id", parameterToString(localVarOptionals.SinceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UntilId.IsSet() {
		localVarQueryParams.Add("until_id", parameterToString(localVarOptionals.UntilId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxResults.IsSet() {
		localVarQueryParams.Add("max_results", parameterToString(localVarOptionals.MaxResults.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NextToken.IsSet() {
		localVarQueryParams.Add("next_token", parameterToString(localVarOptionals.NextToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Expansions.IsSet() {
		localVarQueryParams.Add("expansions", parameterToString(localVarOptionals.Expansions.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.TweetFields.IsSet() {
		localVarQueryParams.Add("tweet.fields", parameterToString(localVarOptionals.TweetFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.UserFields.IsSet() {
		localVarQueryParams.Add("user.fields", parameterToString(localVarOptionals.UserFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.MediaFields.IsSet() {
		localVarQueryParams.Add("media.fields", parameterToString(localVarOptionals.MediaFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.PlaceFields.IsSet() {
		localVarQueryParams.Add("place.fields", parameterToString(localVarOptionals.PlaceFields.Value(), "csv"))
	}
	if localVarOptionals != nil && localVarOptionals.PollFields.IsSet() {
		localVarQueryParams.Add("poll.fields", parameterToString(localVarOptionals.PollFields.Value(), "csv"))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
